# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18U3tKn0-jjOd149QP_kN8WLLjA3YN_fY
"""
!pip install wbdata
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from scipy.optimize import curve_fit
from sklearn.cluster import KMeans
import pandas as pd
import numpy as np
import wbdata
import matplotlib.pyplot as plt
import seaborn as sns
get_ipython().system('pip install wbdata')

#indicator codes
codes = {'NY.GDP.MKTP.CD': 'GDP (current US$)',
         'EG.ELC.ACCS.ZS': 'Access to electricity (% of population)',
         'AG.LND.AGRI.ZS': 'Agricultural land (% of land area)',
         'EN.ATM.CO2E.KT': 'CO2 emissions (kt)',
         'SP.POP.GROW': 'Population growth (annual %)',
         'JI.POP.URBN.ZS': 'Urban population, total',
         }
data = wbdata.get_dataframe(codes, country='all', convert_date=True)


data = data.reset_index()  # Cleaning the column

# The column is renamed
data = data.rename(columns={'country': 'Country', 'date': 'Year'})
data.to_csv('data.csv', index=False)  # Save the data as a csv file
df = pd.read_csv('/content/data.csv')
df.dropna(inplace=True)
df['Country'].unique()

#Clean and transpose the data
def cd(file):
    df1 = pd.read_csv(file, skiprows=4)
    df1 = df1.transpose()
    df1 = df1.dropna(how='all')
    return df1, df1.describe()


df1_transposed, df1_summary = cd('/content/data.csv')
print(df1_transposed.head())
print(df1_summary)
print(cd.__doc__)
countries = ['United States', 'United Kingdom', 'United Arab Emirates', 'India', 'Jordan',
             'Iceland', 'Luxembourg', 'Maldives', 'Singapore', 'Malaysia', 'South Africa', 'China']
df2 = df[df['Country'].isin(countries)]

indicators = ['GDP (current US$)',
              'Access to electricity (% of population)',
              'Agricultural land (% of land area)',
              'CO2 emissions (kt)',
              'Population growth (annual %)',
              'Urban population, total (% of total population)']

df2.sort_values(by='GDP (current US$)',
                ascending=False)  # Sorting in terms of GDP

df2.isnull().sum()
x = df2.iloc[:, 3:5].values
df2 = df2.replace(np.NaN, 0)
df2 = (df2 - df2.mean()) / df2.std()

#Creata a heatmap to show correlation 
plt.figure(figsize=(10, 8))
sns.heatmap(df2.corr(), annot=True)
plt.title('Heatmap to show the Various Indicators')
plt.show()

#K Means Clustering
kmeans = KMeans(n_clusters=5, init="k-means++", n_init=10, random_state=101)
y_pred = kmeans.fit_predict(x)
plt.figure(figsize=(10, 7))
plt.scatter(x[y_pred == 0, 0], x[y_pred == 0, 1], s=100)
plt.scatter(x[y_pred == 1, 0], x[y_pred == 1, 1], s=100)
plt.scatter(x[y_pred == 2, 0], x[y_pred == 2, 1], s=100)
plt.scatter(x[y_pred == 3, 0], x[y_pred == 3, 1], s=100)
plt.scatter(x[y_pred == 4, 0], x[y_pred == 4, 1], s=100)
plt.scatter(kmeans.cluster_centers_[:, 0],
            kmeans.cluster_centers_[:, 1], s=300)
plt.xlabel("Access to electricity (% of population)")
plt.ylabel("Agricultural land (% of land area)")
plt.title("K Means Clustering")
plt.show()
df2.columns


l3 = LabelEncoder()
label = l3.fit_transform(df2['GDP (current US$)'])
df3 = df2.drop('GDP (current US$)', axis='columns')
df3['GDP (current US$)'] = label
print(df3)
x_data = df3[['Urban population, total', 'CO2 emissions (kt)']]
y_data = df3['GDP (current US$)']
x_data.head()
scalar = MinMaxScaler()
scalar.fit(x_data)
new = scalar.transform(x_data)
print(new)

#create a scatter plot
plt.figure(figsize=(20, 8))
sns.set_style(style='whitegrid')
sns.pointplot(y='GDP (current US$)',
              x='Population growth (annual %)', data=df2)
plt.xticks(rotation=90)
plt.title('GDP against Annual Population Growth')

# Visualize the clusters with a scatter plot
xd = np.asarray(x_data)
yd = np.asarray(y_data)
plt.plot(xd, yd, 'o')
plt.title('Total urban population and CO2 emissions (kt) vs GDP (current US$)')
plt.xlabel('Urban population, total and CO2 emissions (kt)')
plt.ylabel('GDP (current US$)')

#curve fit

# Define the linear model


def linear_model(x, a, b):
    return a * x + b


# Fit the model to the data
xdata = df2['GDP (current US$)'].values
ydata = df2['Urban population, total'].values
popt, pcov = curve_fit(linear_model, xdata, ydata)
plt.show()
